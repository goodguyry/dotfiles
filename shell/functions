#!/bin/bash

# **
# Switch to projects folder; open it in Sublime Text
#   Usage: p [project-name] [subdirectory]
# **
function p() {
  # Check for passed argument(s)
  if [ $# -gt 0 ]; then
    # Change to the project root
    cd "$HOME/Projects/$1";

    # Check for Sublime Text
    if [[ $(type -P subl) ]]; then
      # Check for a passed subdirectory
      if [[ $# -gt 1 ]]; then
        # Open the passed subdirectory in Sublime Text
        subl $2;
      else
        # Open the project root in Sublime Text
        subl .;
      fi;
    fi;

    # Check for a .git repo
    if $(git rev-parse --is-inside-work-tree &> /dev/null); then
      clear;
      git status;
      # Bring Terminal forward
      osascript -e 'tell app "Terminal" to activate';
    fi;
  else
    # No arguments; change to $HOME/Projects
    cd "$HOME/Projects";
  fi;
}


# Change working directory to the top-most Finder window location
# http://helpx.adobe.com/photoshop/kb/unit-type-conversion-error-applescript.html
function cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}


# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$@";
}


# Create a temporary plain text file
# Usage: `tmp ext` (creates file: temp.[date string].ext)
# If no extension is passed, defaults to "md"
function tmp() {
  prefix="temp";
  suffix=$(date +%Y%m%d%H%M%S);
  ext="${1:-md}";
  filename="$prefix.$suffix.$ext";
  touch $filename;
}


# Hide individual file(s)
function hide() {
  chflags hidden "$@"
}


# Unhide individual file(s)
function unhide() {
  chflags nohidden "$@"
}


# Recursively delete files that match a certain pattern
# (by default delete all `.DS_Store` files)
cleanup() {
  local q="${1:-*.DS_Store}";
  find . -type f -name "$q" -ls -delete;
}


# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi;
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* *;
  fi;
}


# git branch ahead/behind another
function gcheck() {
  # use first argument or master
  original=${1-master};

  # use the second argument or current branch if not given
  current=`git branch | grep \* | sed s/\*\ //`;
  compare=${2-$current};

  # run git rev-list and capture numbers returned
  result=`git rev-list --left-right --count $original...$compare`;

  numbers=($result);
  printf "\n";
  # print numbers in a pretty message
  if [ ${numbers[0]} -gt 0 ]; then
    echo -e "$(tput setaf 136)$compare is ${numbers[0]} commits behind $original$(tput sgr0)";
  fi;
  if [ ${numbers[1]} -gt 0 ]; then
    echo -e "$(tput setaf 64)$compare is ${numbers[1]} commits ahead of $original$(tput sgr0)";
  fi;
}


# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@";
  }
fi;


# Create a data URI from a file
function datauri() {
  local mimeType=$(file -b --mime-type "$1");
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8";
  fi;
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')" | pbcopy;
  echo "The data URI is on the clipboard.";
}


# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
  local tmpFile="${@%/}.tar";
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null; # GNU `stat`
  )

  local cmd=""
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli";
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz";
    else
      cmd="gzip";
    fi;
  fi;

  echo "Compressing .tar using \`${cmd}\`…";
  "${cmd}" -v "${tmpFile}" || return 1;
  [ -f "${tmpFile}" ] && rm "${tmpFile}";
  echo "${tmpFile}.gz created successfully.";
}


# Compare original and gzipped file size
function gz() {
  local origsize=$(wc -c < "$1");
  local gzipsize=$(gzip -c "$1" | wc -c);
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l);
  printf "orig: %d bytes\n" "$origsize";
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}


# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
  local port="${1:-4000}";
  local ip=$(ipconfig getifaddr en1);
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}";
}


# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}


# ----------------------------------------------
# Add a timestamp to a file or folder; optionally copy the timestamp to the clipboard
#
#   Usage: stamp [-d] string
#
#     -d (optional) : duplicate item before appending the timestamp
#     -c (optional) : copy the timestamp to the clipboard
#     -s=SEPARATOR (optional) : set the separator between the item name and the timestamp
#
#   Change date format in $stamp to alter output
# ----------------------------------------------

function run_help() {

cat <<EOT
Usage: stamp [-d] [-c] [-s=SEPARATOR]

Options:
    -h, --help        Print this help text
    -d                Duplicate the item before appending the timestamp
    -c                Copy the timestamp to the clipboard
    -s=SEPARATOR      Define the separator between the itme name and the timestamp
EOT
}

function stamp() {
  # Help text
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    run_help;
    return;
  fi;

  ERRORMSG="Error: A file or folder is required for timestamping";
  STAMP=$(date +%Y%m%d_%H%M%S);
  DUP=false;
  SEP=${STAMP_SEPARATOR:="."}; # Default separator

  # No args were given
  if [ $# -lt 1 ]; then
    run_help;
    return;
  fi;

  # Test for flags
  for opt in $@; do
    case $opt in
      -d) DUP=true ;;   # Duplicate the item before appending the timestamp
      -c) CLIPBOARD=true ;;   # Copy the timestamp to the clipboard
      -s*) SEP="${opt##*-s=}" ;; # Set the separator between the itme name and the timestamp
      *) ITEM=$opt ;;   # Set ITEM to the other argument
    esac
  done;

  # Copy the timestamp to the clipboard and exit
  if $CLIPBOARD; then
    $(echo "$STAMP" | pbcopy);
    echo "$STAMP copied to the clipboard.";
    # Exit if there's no file/directory passed
    if [[ -z "$ITEM" ]]; then
      return;
    fi;
  fi;

  # Make sure ITEM is set before proceeding
  if [[ -z "$ITEM" ]]; then
    run_help;
    return;
  fi;

  if [ -d "$ITEM" ]; then
    # Split off the trailing slash (if it's there)
    NAME="${ITEM%/*}";
    # Clear the extension
    EXT="";
  else
    # Split the name from the extension
    NAME="${ITEM%.*}";
    # Include the dot in the extension to make things easier in the next step
    EXT=".${ITEM##*.}";
  fi

  if [ $DUP == true ]; then
    # Duplicate the item with timestamp
    cp -r "$NAME"{,"$SEP$STAMP"}"$EXT";
  else
    # Timestamp the item without duplication
    mv "$NAME"{,"$SEP$STAMP"}"$EXT";
  fi;

  unset SEP;
}
