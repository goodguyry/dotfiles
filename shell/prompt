if [[ ${COLORTERM} = gnome-* && ${TERM} = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  export TERM=gnome-256color;
elif infocmp xterm-256color >/dev/null 2>&1; then
  export TERM=xterm-256color;
fi;

	# Solarized colors, taken from http://git.io/solarized-colors.
if tput setaf 1 &> /dev/null; then
  tput sgr0; # reset colors
  BLACK=$(tput setaf 0);
  BLUE=$(tput setaf 68);
  BOLD=$(tput bold);
  CYAN=$(tput setaf 37);
  GRAY=$(tput setaf 240);
  GREEN=$(tput setaf 64);
  LTGRAY=$(tput setaf 245);
  ORANGE=$(tput setaf 166);
  PURPLE=$(tput setaf 125);
  RED=$(tput setaf 124);
  RESET=$(tput sgr0);
  VIOLET=$(tput setaf 97);
  WHITE=$(tput setaf 15);
  YELLOW=$(tput setaf 226);
else
	BOLD='';
  BLACK="\e[1;30m";
  BLUE="\e[1;34m";
  CYAN="\e[1;36m";
  GRAY="\e[1;30m";
  GREEN="\e[1;32m";
  LTGRAY="\e[0;37m";
  ORANGE="\e[1;33m";
  PURPLE="\e[1;35m";
  RED="\e[1;31m";
  RESET="\e[0m";
  VIOLET="\e[1;35m";
  WHITE="\e[1;37m";
  YELLOW="\e[1;33m";
fi;


function parse_git_dirty() {
  # Show "∆" if the stage isn't clean
  [[ $(git status 2> /dev/null | tail -n1) != *'working tree clean'* ]] && echo ' ∆';
}

function parse_git_branch() {
  # Get the Git branch if inside a repo
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/";
}

# Clear prompt variables
unset PS1;
unset PS2;

# If a the prompt variables aren't set, use the default
if [[ ! -n ${PS1} ]]; then
  # Main prompt
  # HH:MM:SS - User@Host
  PS1="\n\[${GRAY}\]\T - \u@\h";
  # New line; Current directory
  PS1+="\n\[${BLUE}\]\$(pwd)";
  # If inside a Git repo, print "on <branch>" at the end of the line
  PS1+="\[${GRAY}\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[${ORANGE}\]\$(parse_git_branch)";
  # Prompt on a new line
  PS1+="\n\[${BLUE}\]\$ \[${LTGRAY}\]";

  # Continuation prompt
  PS2="\[${BLUE}\]: \[${LTGRAY}\]";

fi;

export PS1;
export PS2;
