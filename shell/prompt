#!/bin/bash

if [[ "${COLORTERM}" = gnome-* && "${TERM}" = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
  export TERM='xterm-256color';
fi;

	# Solarized colors, taken from http://git.io/solarized-colors.
if tput setaf 1 &> /dev/null; then
  tput sgr0; # Reset colors.
  BLACK=$(tput setaf 0);
  BLUE=$(tput setaf 68);
  BOLD=$(tput bold);
  CYAN=$(tput setaf 37);
  GRAY=$(tput setaf 240);
  GREEN=$(tput setaf 64);
  LTGRAY=$(tput setaf 245);
  ORANGE=$(tput setaf 166);
  PURPLE=$(tput setaf 125);
  RED=$(tput setaf 124);
  RESET=$(tput sgr0);
  VIOLET=$(tput setaf 97);
  WHITE=$(tput setaf 15);
  YELLOW=$(tput setaf 226);
else
	BOLD='';
  BLACK="\e[1;30m";
  BLUE="\e[1;34m";
  CYAN="\e[1;36m";
  GRAY="\e[1;30m";
  GREEN="\e[1;32m";
  LTGRAY="\e[0;37m";
  ORANGE="\e[1;33m";
  PURPLE="\e[1;35m";
  RED="\e[1;31m";
  RESET="\e[0m";
  VIOLET="\e[1;35m";
  WHITE="\e[1;37m";
  YELLOW="\e[1;33m";
fi;

# h/t https://github.com/necolas/dotfiles
prompt_git() {
  local S='';
  local BRANCHNAME='';

  # Check if the current directory is in a Git repository.
  if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

    # check if the current directory is in .git before running git checks.
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

      # Ensure the index is up to date.
      git update-index --really-refresh -q &>/dev/null;

      # Check for uncommitted changes in the index.
      [[ ! $(git diff --quiet --ignore-submodules --cached) ]] && S+="${GREEN}+${GRAY}";

      # Check for unstaged changes.
      [[ ! $(git diff-files --quiet --ignore-submodules --) ]] && S+="${YELLOW}!${GRAY}";

      # Check for untracked files.
      [[ -n "$(git ls-files --others --exclude-standard)" ]] && S+="${RED}?${GRAY}";

      # Check for stashed files.
      [[ $(git rev-parse --verify refs/stash &>/dev/null) ]] && S+="${PURPLE}\$${GRAY}";

    fi;

    # Get the short symbolic ref.
    # If HEAD isnâ€™t a symbolic ref, get the short SHA for the latest commit.
    # Otherwise, just give up.
    BRANCHNAME="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
                git rev-parse --short HEAD 2> /dev/null || \
                echo '(unknown)')";

    [ -n "${S}" ] && S=" [${S}]";

    echo -e "${1}${BRANCHNAME}${2}${S}";
  else
    return;
  fi;
}

# Clear prompt variables.
unset PS1;
unset PS2;

# If a the prompt variables aren't set, use the default.
if [[ ! -n ${PS1} ]]; then
  # Main prompt
  # HH:MM:SS - User@Host
  PS1="\n\[${GRAY}\]\T - \u@\h";
  # New line; Current directory
  PS1+="\n\[${BLUE}\]\$(pwd)";
  # If inside a Git repo, print "on <branch>" at the end of the line.
  PS1+="\$(prompt_git \"\[${GRAY}\] on \[${ORANGE}\]\" \"\[${GRAY}\]\")"; # Git repository details.
  # Prompt on a new line.
  PS1+="\n\[${BLUE}\]\$ \[${LTGRAY}\]";

  # Continuation prompt.
  PS2="\[${BLUE}\]: \[${LTGRAY}\]";
fi;

export PS1;
export PS2;
